"""
Base Strategy Class
====================
Abstract base class for all trading strategies. Provides a consistent
interface and common functionality.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from datetime import datetime
import pandas as pd
import numpy as np


@dataclass
class Position:
    """Represents an open position"""
    symbol: str
    quantity: float
    entry_price: float
    entry_date: datetime
    side: str  # 'long' or 'short'
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def is_long(self) -> bool:
        return self.side == 'long'

    @property
    def market_value(self) -> float:
        return abs(self.quantity) * self.entry_price

    def unrealized_pnl(self, current_price: float) -> float:
        if self.is_long:
            return (current_price - self.entry_price) * self.quantity
        else:
            return (self.entry_price - current_price) * abs(self.quantity)

    def unrealized_pnl_pct(self, current_price: float) -> float:
        if self.is_long:
            return (current_price / self.entry_price) - 1
        else:
            return (self.entry_price / current_price) - 1


@dataclass
class Signal:
    """Trading signal generated by a strategy"""
    symbol: str
    direction: int  # 1 = long, -1 = short, 0 = flat/close
    strength: float = 1.0  # Signal strength (0-1)
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: Dict[str, Any] = field(default_factory=dict)

    @property
    def is_buy(self) -> bool:
        return self.direction > 0

    @property
    def is_sell(self) -> bool:
        return self.direction < 0

    @property
    def is_flat(self) -> bool:
        return self.direction == 0


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.

    Implement this class to create your own strategies. You must override:
    - generate_signals(): Core logic that produces trading signals

    Optionally override:
    - on_start(): Called before backtesting begins
    - on_end(): Called after backtesting completes
    - on_bar(): Called on each new price bar
    - on_fill(): Called when an order is filled
    - calculate_position_size(): Custom position sizing logic
    """

    def __init__(self, name: str = "BaseStrategy"):
        self.name = name
        self.positions: Dict[str, Position] = {}
        self.signals_history: List[Signal] = []
        self.is_initialized = False

        # Performance tracking
        self._trades: List[Dict] = []
        self._equity_curve: List[float] = []

    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> pd.Series:
        """
        Generate trading signals from price data.

        Args:
            data: DataFrame with OHLCV data (columns: open, high, low, close, volume)
                  Index should be DatetimeIndex

        Returns:
            pd.Series with signal values:
                1 = Long signal
                -1 = Short signal
                0 = No position / Exit

        Example:
            def generate_signals(self, data):
                sma_fast = data['close'].rolling(10).mean()
                sma_slow = data['close'].rolling(30).mean()

                signals = pd.Series(0, index=data.index)
                signals[sma_fast > sma_slow] = 1
                signals[sma_fast < sma_slow] = -1

                return signals
        """
        pass

    def on_start(self, data: pd.DataFrame) -> None:
        """
        Called once before backtesting begins.
        Use for strategy initialization, indicator warmup, etc.
        """
        self.is_initialized = True

    def on_end(self, data: pd.DataFrame, results: Dict) -> None:
        """
        Called once after backtesting completes.
        Use for cleanup, final calculations, report generation.
        """
        pass

    def on_bar(self, timestamp: datetime, bar: pd.Series) -> Optional[Signal]:
        """
        Called on each new price bar during live trading or event-driven backtesting.

        Args:
            timestamp: Current bar timestamp
            bar: Series with OHLCV data for current bar

        Returns:
            Optional Signal if action should be taken
        """
        return None

    def on_fill(self, symbol: str, quantity: float, price: float,
                timestamp: datetime, side: str) -> None:
        """
        Called when an order is filled.
        Use to update position tracking, logging, etc.
        """
        if side == 'buy':
            self.positions[symbol] = Position(
                symbol=symbol,
                quantity=quantity,
                entry_price=price,
                entry_date=timestamp,
                side='long'
            )
        elif side == 'sell' and symbol in self.positions:
            del self.positions[symbol]

    def calculate_position_size(self, signal: Signal, capital: float,
                               price: float, volatility: float = None) -> float:
        """
        Calculate position size for a signal.
        Override this for custom position sizing logic.

        Default: Equal weight (10% of capital per position)
        """
        max_position_value = capital * 0.10
        shares = max_position_value / price
        return shares

    def get_required_history(self) -> int:
        """
        Return number of bars needed for indicator warmup.
        Override if your strategy needs historical data.
        """
        return 50

    def validate_data(self, data: pd.DataFrame) -> bool:
        """Validate input data has required columns"""
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        missing = [col for col in required_columns if col not in data.columns]
        if missing:
            raise ValueError(f"Missing required columns: {missing}")
        return True

    def preprocess_data(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Preprocess data before signal generation.
        Override for custom preprocessing (normalization, feature engineering, etc.)
        """
        # Basic cleaning
        df = data.copy()
        df = df.dropna(subset=['close'])

        # Ensure proper column names (lowercase)
        df.columns = df.columns.str.lower()

        return df

    def get_parameters(self) -> Dict[str, Any]:
        """Return strategy parameters for optimization/logging"""
        return {}

    def set_parameters(self, **params) -> None:
        """Set strategy parameters"""
        for key, value in params.items():
            if hasattr(self, key):
                setattr(self, key, value)

    def __repr__(self) -> str:
        params = self.get_parameters()
        param_str = ", ".join(f"{k}={v}" for k, v in params.items())
        return f"{self.name}({param_str})"


class StrategyEnsemble:
    """
    Combine multiple strategies with weighted voting.
    """

    def __init__(self, strategies: List[BaseStrategy],
                 weights: Optional[List[float]] = None):
        self.strategies = strategies
        self.weights = weights or [1.0 / len(strategies)] * len(strategies)

        if len(self.strategies) != len(self.weights):
            raise ValueError("Number of strategies must match number of weights")

        # Normalize weights
        total = sum(self.weights)
        self.weights = [w / total for w in self.weights]

    def generate_signals(self, data: pd.DataFrame) -> pd.Series:
        """Generate consensus signals from all strategies"""
        all_signals = []

        for strategy, weight in zip(self.strategies, self.weights):
            signals = strategy.generate_signals(data)
            all_signals.append(signals * weight)

        combined = pd.concat(all_signals, axis=1).sum(axis=1)

        # Convert to discrete signals
        final_signals = pd.Series(0, index=data.index)
        final_signals[combined > 0.3] = 1
        final_signals[combined < -0.3] = -1

        return final_signals

    def add_strategy(self, strategy: BaseStrategy, weight: float = 1.0) -> None:
        """Add a strategy to the ensemble"""
        self.strategies.append(strategy)
        self.weights.append(weight)

        # Renormalize
        total = sum(self.weights)
        self.weights = [w / total for w in self.weights]
